# Инструкция по работе с Git и с GitHub
## Что такое система контроля сохранения версий?
Система контроля версий - это специальная программа, которая позволяет администрировать процесс создания какого-либо файла (файлов) одновременно большим количеством людей, фиксируя все изменения с указанием авторства, хронологии создания, а также с возможностью одновременного ведения нескольких веток, в которых происходят изменения различных версий одного и того же файла, с последующим утверждением окончательной версии и слиянием утвержденных изменений.

Очень неплохой мануал лежит [здесь,](https://habr.com/ru/post/522078/), а также [здесь](https://githowto.com/ru) и [здесь](https://bookflow.ru/shpargalka-po-git/)
## Что такое Git?
Git - это одна из реализаций систем контроля версий. Git позволяет управлять изменениями, создавать фиксации, ветки, а также сливать их.

Git, кроме командного интерфейса, реализованного чере терминальные программы, имеет и графическую оболочку, в которой можно работать привычным способом, через систему меню при помощи манипулятора мыши. Хотя программисты предпочитают консольную версию и считают, что работать вводя текстовые команды не отрывая рук от клавиатуры намного быстрее.

## Подготовка репозитория
Репозиторий - это хранилище файлов, поддерживающих версионность. Создать репозиторий можно с помощью применения в папке команды *git init*

команда _**git init**_ запущенная git-ом в какой-либо папке превращает эту папку в репозиторий, то есть в хранилище. Это значит, что в этой папке git начинает отслеживать изменения всех файлов любого типа. После этой команды он создает в папке собственную служебную структуру папок и файлов.

после того, как мы создали файл в отслеживаемой папке, нужно указать git, что этот файл должен быть отслеживаем, это делается командой 

_**git add <имя файла>**_ 
## Создание сохранений
Далее, после того, как мы указали, что файл нужно отслеживать, мы можем создавать историю изменений этого файла, создавая "точки восстановления". 

Мы можем создавать "сохранения" наших версий файлов. Такие "сохранения" называются фиксациями или комитами.

Сделать комит можно с помощью команды *git commit* и **ОБЯЗАТЕЛЬНО** использовать флаг -m после чего в кавычках написать сообщение. 

Например, вот так: 

_**git commit -m "Текст Вашего комментария"**_

или так:

_**git commit -am "Текст комита"**_ - здесь в ключ -am совмещены вместе два ключа -а и -m. Ключ -а добавляет все файлы репозитория в отслеживание, кроме указанных в файле игнора, а ключ -m делает комит.

## Перемещение между сохранениями
Перемещаться между нашими сохранениями можно с помощью команды *Git checkout*. Для этого достаточно применить команду *git checkout <номер сохранения>*.

Кроме того, данная команда позволяет переключаться с одной ветки на другую, при наличии нескольких веток в  дереве проекта. Например, вот так: 

*git checkout <'new branch name'>*

При применении данной команды для перехода с текущей ветки на коммит, имеющий хронологию создания с началом в другой ветке, создается неприятная ситуация с "Отрезанной головой". 

Git выдает ошибку: _**'detached HEAD state'**_. 

Очень доходчиво про ветвление и возникновение данной ошибки разжевано [здесь](http://pr0git.blogspot.com/2015/02/git_27.html) и [здесь](http://pr0git.blogspot.com/2015/03/git.html)

Можно отменить изменения с помощью команд *git revert*, *git reset*

_**git revert <номер комита>**_ - отменяет изменения до указанной версии и создает новый комит, со ссылкой на текущий, как на родительский. Используется для редактирования истории комитов при совместной работе в удаленном репозитории.

_**git reset --hard <номер комита>**_ - отменит изменения до указанного комита и затрет всю историю изменений после этого комита. Используется для редактирования истории комитов на локальном репозитории.
## Журнал изменений
Журнал изменений вызывается при помощи команды _**git log**_ - при вызове данной команды на экран выводится вся история созданных комитов с указанием их хэша и содержанием коментариев, которые были созданны при записи комитов.

Более "продвинутая" версия этой команды вызывается при помощи ключа --graph:

 _**git log --graph**_ - рисует средствами псевдографики "дорожную карту" комитов. В этом случае git показывает не только историю создания всех коммитов, но также при помощи средств псевдографики изображает иерархическую схему созданных комитов.

а также команда

_**git reflog**_

Эта команда выводит полную историю всех действий с репозиторием

## Ветки в Git
Новая ветка создается с использованием команды git branch
## Слияние веток и решение конфликтов

_**git merge < имя ветки, которую нужно слить с текущей>**_

_**git rebase**_ - При ребейзе Git по сути копирует набор коммитов и переносит их в другое место. 

Например:

_**git rebase main**_ - скопирует текущий комит (то есть на которм мы находимся), изменит его хэш, далее сдвинет указатель на породивший его комит с реального на комит указанный в команде, то есть на main, то есть сделает для текущего комита родительским комит main (поставит текущий комит впереди комита main)

## Удаление веток
Удалить ветку можно при помощи команды:

_**git branch -d <имя ветки>**_

Также, для прямого (принудительного) перемещения указателя текущей ветки - HEAD, используется команда создания новой ветки с ключом -f (force):

_**git branch -f < Current place > < New place >**_

**< Current place >**  - имя комита с которого нужно переместить указатель ветки этого комита;

**< New place >**  -  имя комита, куда пермещаем указатель текцущей ветки, можно также указать относительную ссылку, то есть ссылку относительно текущего указателя заголовка HEAD. Запись HEAD~3 означает, что местоположение находится от текущего положения HEAD на 3 комита назад.

## Скачивание удаленного репозитория
Список веток на удаленном репозитории:

git ls-remote - показывает хэши сохранений

git fetch

git branch -r --sort=committerdate - отсортированный по времени создания

git branch -r

Скачать удаленный репозиторий возможно при помощи команды "git clone". Выполняется это так: 

*git clone <адрес удаленного репозитория>*, 

например:

*'git clone https://github.com/AbubakirovRA/version_control_lection_3.git'*

**Переписка по поводу скачивания ветки из удаленного репо:**

Добрый вечер)) вот такой вопрос - кто уже пробовал поработать в GitHub? Я делаю ветку в GitHub, пытаюсь её перетащить в локальный репозиторий, а она не перетаскивается. Из локального в GitHub без проблем. Может кто сталкивался?

      Добрый день. Я столкнулся с такой особенностью, при работе с удаленным репозиторием: для того чтобы протолкнуть свои изменения, созданные на локальном компьютере во вновь созданной ветке, то в команде push нужно указывать удаленный репозиторий origin, а вот ветку не master, иначе git скажет, что все изменения уже добавлены, а нужно указать имя вновь созданной ветки. Тогда Git на удаленном репозитории создаст новую ветку и скопирует туда  локальные изменения. git push origin <'имя вновь созданной ветки'>

Добрый день. Да я вчера спросил у преподавателя. То есть из удаленного репозитория чтоб перетянуть ветку, созданную на удалённом репозитории, нужно написать git pull origin <имя ветки>. Но, ветка не переносится как таковая - она переносится с merge. То есть если я перетяну командой(git pull origin <имя ветки>.) удалённую ветку в основной репозиторий, то она перенесется информация из удаленной ветки.
По факту ветка не переносится, а переносится информацию из этой ветки в ветку на которой ты находишься в локальном репозиторий.
      
      Ну, да. Я так и подумал, что здесь наверное обратный процесс. То есть нужно указать имя удаленной ветки, но только с командой pull

То есть у меня локально две ветки, а удалённо 3. И вот если третью ветку я попытаюсь перетянуть в локальный, то по факту у меня останется локально так же 2 ветки, но информации будет как из трёх веток удаленного. Хотя конечно странно, почему всё таки вся ветка не тянется ((

      ну, да это особенность команды pull, если нужна копия этой ветки локально, то нужно создать эту ветку, перейти на нее и тогда выполнить команду pull с указанием удаленной ветки

Потому что есть представление - из локального репозитория я могу запушить в удаленный всё свои ветки. А обратно немного с костылями😄

      я тоже так думал - не тут-то было, на семинаре эти тонкости как то я не усвоил, пришлось методом тыка доходить, этот origin master  с толку сбивал сильно. создаю локально новую ветку, пишу git push origin master, git  мне отвечает - все изменения уже внесены, и хоть что ты с ним делай. После плясок вокруг интернета пробую git push origin <имя локальной новой ветки>, и вуаля, все изменения на удаленном репозитории выполнены.

А у меня при создании ветки и добавлении документа в неё с коммитом, достаточно команды git push. И всё, всё уносится в облако.

      ну, может это потому, что я изменял форкнутый репозиторий?

А, тогда наверное да. Потому как в этот документ мы можем добавить"что-то" и только это "что-то" запушить.

# Git setup Instruction #

### Download the Git:

follow this links:
+ [Windows](https://git-scm.com/download/win)
+ [MacOS](https://git-scm.com/download/mac)
+ [Linux](https://git-scm.com/download/linux)
### Install it on your computer
### Next, you need to configure Git: 

To show all installed setup use command with a keys:

git config --list --show-origin

First, that you need to do to setup Git:
----------------------------------------
you need to enter your name and your email address. For example:

+ **git config --global user.name "AbubakirovRA"**

+ **git config --global user.email AbubakirovRA@yandex.ru**

Several commands for working in Git
===================================
 + **git version** - show version installed Git
 
 + **git init** - initialisation current workdirectory to repository
 + **git status** - show all change in tracking directory
+ **git add** - add file to tracking of change in current directory
+ **git commit** - creating the "point of recovery" current directory - repositry. If use a key -m, than posible add message for current "point of recovery"
+ **git log** - show all commits an current repository
+ **git checkout** - restore specified commit
+ **git checkout master** - return to master branch
+ **git diff** - compare current save with previous version


detailed install and setup instructions can be found at the link: [Install&Setup](https://git-scm.com/book/ru/v2/)

  ![Picture](https://gbcdn.mrgcdn.ru/uploads/avatar/3320581/attachment/thumb-da6ca1bdffc83bcc292b06d091d82d14.png "GeekBrains-AbubakirovRA")
